"""
file_generator.py

This module defines functions to generate PDF and PowerPoint files from markdown text.
Functions:
- generate_pdf(md_text: str, output_path: str = "output/output.pdf") -> str (This function generates a PDF file from markdown text)
- generate_ppt(md_text: str, output_path: str = "output/output.pptx") -> str (This function generates a PowerPoint file from markdown text to html using BeautifulSoup for parsing and python-pptx for pptx generation)

WARNING!
Changes to this file may affect the functionality of PDF and PPT generation as it depends on input generated by LLM using prompts defined in lib/prompt.py.
"""

import os
import re
import markdown
from markdown_pdf import MarkdownPdf, Section
from bs4 import BeautifulSoup
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN
from md2pdf.core import md2pdf

import shared.logger as logger

def generate_pdf(md_text: str, output_path: str = "output/output.pdf") -> str:
    """
    Convert markdown text to PDF file.
    
    Args:
        md_text (str): The markdown content to convert
        output_path (str): Path where the PDF file will be saved
        
    Returns:
        str: Path to the generated PDF file
        
    Raises:
        ValueError: If md_text is empty
        IOError: If unable to write to output_path
    """
    logger.info(f"Starting PDF generation with output path: {output_path}")
    
    if not md_text.strip():
        logger.error("Markdown text is empty")
        raise ValueError("Markdown text cannot be empty")
    
    logger.debug(f"Markdown text length: {len(md_text)} characters")
    
    try:
        # Create MarkdownPdf instance with table of contents up to level 3 and optimization
        logger.debug("Creating MarkdownPdf instance with toc_level=3 and optimization enabled")
        pdf = MarkdownPdf(toc_level=3, optimize=True)
        
        # Set PDF metadata
        logger.debug("Setting PDF metadata")
        pdf.meta["creator"] = "PPTGen-AI"
        pdf.meta["producer"] = "PPTGen-AI"
        pdf.meta["title"] = "AI-Generated PDF Document"
        
        # Add the markdown content as a single section
        # Enable TOC generation for headings
        logger.debug("Adding markdown content as section with TOC enabled")
        section = Section(md_text, toc=True)
        pdf.add_section(section)
        
        # Ensure the output directory exists
        output_dir = os.path.dirname(os.path.abspath(output_path))
        if output_dir and not os.path.exists(output_dir):
            logger.info(f"Creating output directory: {output_dir}")
            os.makedirs(output_dir)
        else:
            logger.debug(f"Output directory already exists: {output_dir}")
        
        # Save the PDF
        logger.info("Saving PDF file...")
        pdf.save(output_path)
        
        final_path = os.path.abspath(output_path)
        logger.info(f"PDF generation completed successfully: {final_path}")
        return final_path
        
    except Exception as e:
        logger.error(f"PDF generation failed: {str(e)}")
        raise IOError(f"Failed to generate PDF: {str(e)}")


def generate_ppt(md_text: str, output_path: str = "output/output.pptx") -> str:
    """
    Generate PowerPoint presentation from markdown text using BeautifulSoup for HTML parsing.
    
    Args:
        md_text: Markdown content as string
        output_path: Output path for the PowerPoint file (default: "output.pptx")
    
    Returns:
        str: Path to the generated PowerPoint file
    """
    try:
        # Convert Markdown to HTML
        html_content = markdown.markdown(md_text)
        
        # Parse HTML with BeautifulSoup
        soup = BeautifulSoup(html_content, 'html.parser')
        
        # Create PowerPoint presentation
        prs = Presentation()
        
        # Define colors (similar to original #C54300)
        header_color = RGBColor(197, 67, 0)  # #C54300
        
        # Function to add slide with content
        def add_slide_with_content(prs, title, content_elements):
            slide_layout = prs.slide_layouts[1]  # Title and Content layout
            slide = prs.slides.add_slide(slide_layout)
            
            # Set title
            title_shape = slide.shapes.title
            title_shape.text = title
            title_shape.text_frame.paragraphs[0].font.color.rgb = header_color
            title_shape.text_frame.paragraphs[0].font.size = Pt(32)
            title_shape.text_frame.paragraphs[0].font.bold = True
            
            # Add content
            content_shape = slide.shapes.placeholders[1]
            text_frame = content_shape.text_frame
            text_frame.clear()
            
            for element in content_elements:
                p = text_frame.add_paragraph()
                if element['type'] == 'paragraph':
                    p.text = element['text']
                    p.font.size = Pt(18)
                elif element['type'] == 'list_item':
                    p.text = f"â€¢ {element['text']}"
                    p.font.size = Pt(16)
                    p.level = 1
                elif element['type'] == 'bold':
                    p.text = element['text']
                    p.font.bold = True
                    p.font.size = Pt(20)
                    p.alignment = PP_ALIGN.CENTER
        
        # Parse HTML content and create slides
        current_slide_title = ""
        current_slide_content = []
        slides_data = []
        
        for element in soup.find_all(['h1', 'h2', 'h3', 'p', 'ul', 'strong']):
            if element.name == 'h1':
                # Title slide
                if current_slide_title and current_slide_content:
                    slides_data.append((current_slide_title, current_slide_content))
                
                # Create title slide
                title_slide_layout = prs.slide_layouts[0]  # Title slide layout
                title_slide = prs.slides.add_slide(title_slide_layout)
                title_slide.shapes.title.text = element.get_text().strip()
                title_slide.shapes.title.text_frame.paragraphs[0].font.color.rgb = header_color
                title_slide.shapes.title.text_frame.paragraphs[0].font.size = Pt(44)
                
                current_slide_title = ""
                current_slide_content = []
                
            elif element.name in ['h2', 'h3']:
                # Start new slide
                if current_slide_title and current_slide_content:
                    slides_data.append((current_slide_title, current_slide_content))
                
                current_slide_title = element.get_text().strip()
                current_slide_content = []
                
            elif element.name == 'p':
                text = element.get_text().strip()
                if text:
                    current_slide_content.append({'type': 'paragraph', 'text': text})
                    
            elif element.name == 'ul':
                # Process list items
                for li in element.find_all('li'):
                    current_slide_content.append({'type': 'list_item', 'text': li.get_text().strip()})
                    
            elif element.name == 'strong':
                text = element.get_text().strip()
                if text:
                    current_slide_content.append({'type': 'bold', 'text': text})
        
        # Add the last slide
        if current_slide_title and current_slide_content:
            slides_data.append((current_slide_title, current_slide_content))
        
        # Create slides from parsed data
        for title, content in slides_data:
            add_slide_with_content(prs, title, content)
        
        # Ensure output path has .pptx extension
        if not output_path.endswith('.pptx'):
            output_path = output_path.replace('.ppt', '.pptx')
        
        # Save the presentation
        prs.save(output_path)
        return output_path
        
    except Exception as e:
        raise Exception(f"Error generating PowerPoint: {str(e)}")
